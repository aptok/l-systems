* Introduction
The motivation was to try out the programming patterns teached in TLS
to reproduce the image in TABOP. To do this [[https://www.r-project.org/][R]] was the choosen
programming language.
* L-Systems
In 'The Algorithmic Beauty of Plants' [cite:@Prusinkiewicz1990-ht] we
find the following definition:
#+begin_quote 
Let $V$ denote an alphabet, $V^∗$ the set of all words over $V$ , and
$V^+$ the set of all nonempty words over $V$ . A string OL-system is an
ordered triplet $G = \langle V, ω, P \rangle$ where $V$ is the alphabet of the system,
$ω ∈ V^+$ is a nonempty word called the axiom and $P ⊂ V × V^∗$ is a
finite set of productions. A production $(a, χ) ∈ P$ is written as $a →
χ$. The letter $a$ and the word $χ$ are called the predecessor and the
successor of this production, respectively. It is assumed that for any
letter $a ∈ V$ , there is at least one word $χ ∈ V^∗$ such that $a → χ$. If
no production is explicitly specified for a given predecessor $a ∈ V$ , the
identity production $a → a$ is assumed to belong to the set of productions
$P$. An OL-system is deterministic (noted DOL-system) if and only if
for each $a ∈ V$ there is exactly one $χ ∈ V^∗$ such that $a → χ$.

Let $µ = a_1 ... a_m$ be an arbitrary word over $V$. The word $ν =
χ_1 ... χ_m ∈ V^∗$ is directly derived from (or generated by) $\mu$, noted $\mu ⇒
ν$, if and only if $a_i → χ_i$ for all $i = 1,...,m$. A word $ν$ is generated by
$G$ in a derivation of length $n$ if there exists a developmental sequence of
words $\mu_0, \mu_1,..., \mu_n$ such that $\mu_0 = ω, \mu_n = ν$ and $\mu_0 ⇒ µ_1 ⇒ ... ⇒
\mu_n$.
#+end_quote

It very soon becomes clear that we need to include letters with
subscripts of only one character, like $a_r$ and $F_l$ into our
alphabet. Therefore we transfrom the string $\nu$ into a list of
letters that can have a subscripts. We do this wiht the funtion
~letters_in_nu~ that looks at the first three characters of $\nu$ and
depending on the second character chooses between to cases. In one
case there is just a letter and it is added to the the list
~letters~. In the second case we have a letter with a subscript of one
charcter and paste all three characters together and add it to the
list ~letters~.

The turtle interpreted characters, for now ~F,f,n,+,-~, are not allowed as
subscripts.

\newpage
#+begin_src R :tangle lsystem.r :eval no
  letters_in_nu <- function(nu) {
    letters <- c()
    while (nchar(nu) > 0) {
      a <- substring(nu,1,1)
      b <- substring(nu,2,2)
      c <- substring(nu,3,3)
      if (b == "_") {
        letters <- c(paste(a,b,c,sep=""), letters)
        nu <- substring(nu,4)
      } else {
        letters <- c(a, letters)
        nu <- substring(nu,2)
      }    
    }
    rev(letters[letters != ""])
  }

  lsystem <- function(alphabet, axiom, productions) {
    function(n) {
      new_word <- ""
      while (n > 0) {
        for (symbol in letters_in_nu(axiom)) {
          new_word  <- paste(new_word,
                             productions[symbol],
                             sep="")
        }
        n <- n - 1
        axiom <- new_word
        new_word <- ""
      }
      axiom
    }
  }

  #+end_src

The above code is tangled into ~lsystem.r~.
\newpage  
* The Turtle Interpreter
In [cite:@Prusinkiewicz1990-ht] the turtle is defined:

#+begin_quote
A state of the turtle is defined as a triplet $(x, y, α)$, where the
Cartesian coordinates $(x, y)$ represent the turtle’s position, and
the angle $α$, called the heading, is interpreted as the direction in
which the turtle is facing. Given the step size $d$ and the angle
increment $δ$, the turtle can respond to commands represented by the
following symbols:

- ~F~ :: Move forward a step of length $d$. The state of the turtle changes
  to $(x, y, α)$, where $x = x + d cos α$ and $y = y + d sin α$. A
  line segment between points $(x, y)$ and $(x' , y')$ is drawn.
  

- ~f~ :: Move forward a step of length $d$ without drawing a line.

- ~+~ :: Turn left by angle $δ$. The next state of the turtle is $(x, y,
  α+δ)$. The positive orientation of angles is counterclockwise.

- ~−~ :: Turn right by angle $δ$. The next state of the turtle is $(x, y,
  α − δ)$.

Given a string $ν$, the initial state of the turtle $(x_0, y_0, α_0)$
and fixed Interpretation parameters $d$ and $δ$, the turtle
interpretation of $ν$ is the figure (set of lines) drawn by the turtle
in response to the string $ν$.
#+end_quote

#+begin_src R :tangle turtle.r 
    turtle <- function(x, y, heading, stepsize, angle_increment) {

      x_orig <- x
      y_orig <- y
      heading_orig <- heading
      turtle_trace <- list(x1=c(x),x2=c(x),y1=c(y),y2=c(y))
      turtle_stack <- list(x=x,y=y,heading=heading)

      reset <- function() {
        x <<- x_orig
        y <<- y_orig
        turtle_trace <<- list(x1=c(x),x2=c(x),y1=c(y),y2=c(y))
        heading <<- heading_orig
      }

      forward <- function() {
        x <<- x + stepsize * cos(heading)
        y <<- y + stepsize * sin(heading)
      }

      forward_draw <- function() {
        turtle_trace$x1 <<- c(x, turtle_trace$x1)
        turtle_trace$y1 <<- c(y, turtle_trace$y1)
        forward()
        turtle_trace$x2 <<- c(x, turtle_trace$x2)
        turtle_trace$y2 <<- c(y, turtle_trace$y2)
      }

      turn_right <- function() {
        heading <<- heading - angle_increment
      }

      turn_left <- function() {
        heading <<- heading + angle_increment
      }

      draw_turtle <- function(ls) {
        print(c(range(c(turtle_trace$x1,turtle_trace$x2)),
                range(c(turtle_trace$y1,turtle_trace$y2))))

      plot(x=range(c(turtle_trace$x1,turtle_trace$x2)),
             y=range(c(turtle_trace$y1,turtle_trace$y2)),
             type="n", ann=FALSE, axes=FALSE)

        for (i in 1:length(turtle_trace$x1)) {
          lines(x=c(turtle_trace$x1[i], turtle_trace$x2[i]),
                y=c(turtle_trace$y1[i], turtle_trace$y2[i]))
        }
      }

      print_turtle_trace <- function() {
  #      print(turtle_trace)
        print(heading*(180/pi))
      }

      push <- function() {
        turtle_stack[[length(turtle_stack) + 1]] <<-
          list(x = x, y = y, heading = heading)
      }

      pop <- function() {
        last_turtle <- turtle_stack[[length(turtle_stack)]]
        turtle_stack[[length(turtle_stack)]] <<- NULL
        x <<- last_turtle$x
        y <<- last_turtle$y
        heading <<- last_turtle$heading
      }

      function_table <-
        list("F" = forward_draw,
             "f" = forward,
             "-" = turn_right,
             "+" = turn_left,
             "n" = reset,
             "d" = draw_turtle,
             "p" = print_turtle_trace,
             "[" = push,
             "]" = pop)

      iter_over_nu <- function(nu) {
        for (i in 1:nchar(nu)) {
          a <- substring(nu,i,i)
          if (a %in% names(function_table)) {
            function_table[[a]]()
          }
        }
      }

      function(nu) {
        iter_over_nu(nu)
      }
    }
  #+end_src

  #+RESULTS:

The above code is tangled into ~turtle.r~

We can now source the two files ~lsystem.r~ and ~turtle.r~ and produce
some turtle drawings.
\newpage
* Examples
** Koch Island
#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F", "f", "+", "-")
  axiom <- c("F-F-F-F")
  productions <- c("F" = "F-F+F+FF-F-F+F",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi, 1, pi/2)
  t(l(3))
  png("koch-island.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1

#+attr_latex: :width 250
#+CAPTION: The Koch Island \newline
#+CAPTION: ~axiom <- c("F-F-F-F")~ \newline
#+CAPTION: ~productions <- c("F" = "F-F+F+FF-F-F+F")~ \newline
#+CAPTION: ​\hspace{3.6cm}​ ~"+" = "+",~ \newline
#+CAPTION: ​\hspace{3.6cm}​ ~"-" = "-",~ \newline
#+CAPTION: ​\hspace{3.6cm}​ ~"f" = "f")~ \newline
#+CAPTION: ~n <- 3~
file:koch-island.png

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F", "f", "+", "-")
  axiom <- c("F-F-F-F")
  productions <- c("F" = "F+FF-FF-F-F+F+FF-F-F+F+FF+FF-F",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi, 1, pi/2)
  t(l(2))
  png("koch-island-variation.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1

#+attr_latex: :width 10cm :height 10cm
[[file:koch-island-variation.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F", "f", "+", "-")
  axiom <- c("-F")
  productions <- c("F" = "F+F-F-F+F",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, 1, pi/2)
  t(l(4))
  png("snowflake-variation.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1

#+attr_latex: :width 15cm :height 7cm
[[file:snowflake-variation.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F", "f", "+", "-")
  axiom <- c("F+F+F+F")
  productions <- c("F" = "F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF",
                   "+" = "+",
                   "-" = "-",
                   "f" = "ffffff")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, .1, pi/2)
  t(l(2))
  png("islands-and-lakes.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1

#+attr_latex: :width 15cm :height 15cm
[[file:islands-and-lakes.png]]

* Drawing the Turtle Trace
We want a function that given the parameters name, l-system, turtle
and number of recursions n draws the turtle traces into a png file.

** FASS
#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F_l", "F_r", "f", "+", "-", "[", "]")
  axiom <- c("F_l")
  productions <- c("F_l" = "F_l+F_r++F_r-F_l--F_lF_l-F_r+",
                   "F_r" = "-F_l+F_rF_r++F_r+F_l--F_l-F_r",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, .1, (60*pi)/180) 
  t(l(4))
  png("hexagonal-gosper-curve.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1

#+attr_latex: :width 10cm :height 10cm
[[file:hexagonal-gosper-curve.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F_l", "F_r", "f", "+", "-", "[", "]")
  axiom <- c("-F_l")
  productions <- c("F_l" = paste(
                     "F_lF_l-F_r-F_r+F_l+F_l-F_r-F_r",
                      "F_l+F_r+F_lF_lF_r-F_l+F_r+F_lF_l",
                      "+F_r-F_lF_r-F_r-F_l+F_l+F_rF_r-",
                     sep=""),
                   "F_r" = paste(
                     "+F_lF_l-F_r-F_r+F_l+F_lF_r+F_l-",
                     "F_rF_r-F_l-F_r+F_lF_rF_r-F_l-F_r",
                     "F_l+F_l+F_r-F_r-F_l+F_l+F_rF_r",
                     sep=""),
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, .1, (90*pi)/180) 
  t(l(2))
  png("quadratic-gosper-curve.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1

#+attr_latex: :width 10cm :height 10cm
[[file:quadratic-gosper-curve.png]]


** Branching
#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F", "f", "+", "-", "[", "]")
  axiom <- c("F")
  productions <- c("F" = "F[+F]F[-F]F",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, .1, (25.7*pi)/180) 
  t(l(5))
  png("branching1.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1
#+attr_latex: :width 2.5cm :height 10cm
[[file:branching1.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F", "f", "+", "-", "[", "]")
  axiom <- c("F")
  productions <- c("F" = "F[+F]F[-F][F]",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, 1, (20*pi)/180) 
  t(l(5))
  png("branching2.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1
#+attr_latex: :width 4cm :height 10cm
[[file:branching2.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("F", "f", "+", "-", "[", "]")
  axiom <- c("F")
  productions <- c("F" = "FF-[-F+F+F]+[+F-F-F]",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, 1, (22.5*pi)/180) 
  t(l(4))
  png("branching3.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1
#+attr_latex: :width 6cm :height 10cm
[[file:branching3.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("X", "F", "f", "+", "-", "[", "]")
  axiom <- c("X")
  productions <- c("X" = "F[+X]F[-X]+X",
                   "F" = "FF",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, 1, (20*pi)/180) 
  t(l(8))
  png("branching4.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1
#+attr_latex: :width 6cm :height 10cm
[[file:branching4.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("X", "F", "f", "+", "-", "[", "]")
  axiom <- c("X")
  productions <- c("X" = "F[+X][-X]FX",
                   "F" = "FF",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, 1, (25.7*pi)/180) 
  t(l(8))
  png("branching5.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1
#+attr_latex: :width 6cm :height 10cm
[[file:branching5.png]]

#+begin_src R :eval yes
  source("lsystem.r")
  source("turtle.r")
  alphabet <- c("X", "F", "f", "+", "-", "[", "]")
  axiom <- c("X")
  productions <- c("X" = "F-[[X]+X]+F[+FX]-X",
                   "F" = "FF",
                   "+" = "+",
                   "-" = "-",
                   "f" = "f",
                   "[" = "[",
                   "]" = "]")
  l <- lsystem(alphabet, axiom, productions)
  t <- turtle(0, 0, pi/2, 1, (22.5*pi)/180) 
  t(l(6))
  png("branching6.png")
  t("d")
  dev.off()
#+end_src

#+RESULTS:
: 1
#+attr_latex: :width 6cm :height 10cm
[[file:branching6.png]]

* Literature
#+print_bibliography:
* config :noexport:
#+PROPERTY: :eval never-export
#+LANGUAGE:  de
#+TITLE: L-Systems in R
#+OPTIONS:   H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LaTeX_CLASS: scrartcl
#+LaTeX_CLASS_OPTIONS: [hidelinks,12pt,a4paper,titlepage]
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{lastpage}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{unicode-math}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \newfontfamily\listingsfont[Scale=0.85]{FreeSans.ttf}
#+LATEX_HEADER: \lstset{basicstyle=\footnotesize\ttfamily, breaklines=true, frame=single, keywordstyle=\listingsfont\bfseries, stringstyle=\ttfamily, commentstyle=\ttfamily, showstringspaces=false}
##+LATEX_HEADER: \usepackage[ngerman]{babel}
#+LATEX_HEADER: \setmainfont{unicode.joanna.ttf}
;;#+LATEX_HEADER: \setmathfont{XITS Math}
#+LATEX_HEADER: \setsansfont{Vollkorn-Regular.ttf}
#+LATEX_HEADER: \addtokomafont{pagenumber}{\small \sffamily}
#+LATEX_HEADER: \setkomafont{author}{\sffamily}
#+LATEX_HEADER: \setkomafont{date}{\sffamily}
#+LATEX_HEADER: \author{Alexander Ptok}
#+LATEX_HEADER: \usepackage{scrlayer-scrpage}
#+LATEX_HEADER: \pagestyle{scrheadings}
#+LATEX_HEADER: \lohead{Alexander Ptok}
#+LATEX_HEADER: \cohead{$\lambda$}
#+LATEX_HEADER: \rohead{\today}
#+LATEX_HEADER: \lofoot{}
#+LATEX_HEADER: \cofoot{\thepage\ von \pageref{LastPage}}
#+LATEX_HEADER: \rofoot{}
#+LATEX_HEADER: \setheadsepline{0.4pt}
#+LATEX_HEADER: \usepackage{lastpage}
#+LATEX_HEADER: \RequirePackage{fancyvrb}
#+LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}
#+bibliography: l-systems-in-r.bib
